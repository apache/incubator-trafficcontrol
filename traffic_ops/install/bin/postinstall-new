#!/usr/bin/perl
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

use lib qw(/opt/traffic_ops/install/lib /opt/traffic_ops/install/lib/perl5 /opt/traffic_ops/app/local/lib/perl5 /opt/traffic_ops/app/lib);
$ENV{PATH}     = "/opt/traffic_ops/install/bin:$ENV{PATH}";
$ENV{PERL5LIB} = "/opt/traffic_ops/install/lib:/opt/traffic_ops/install/lib/perl5:/opt/traffic_ops/app/local/lib/perl5:/opt/traffic_ops/app/lib";

use strict;
use warnings;

use Safe;
use JSON;
use POSIX;
use File::Basename qw{dirname};
use File::Path qw{make_path};
use InstallUtils qw{ :all };
use Digest::SHA1 qw(sha1_hex);
use Data::Dumper qw(Dumper);
use Scalar::Util qw(looks_like_number);

use Getopt::Long;

# paths of the output configuration files
our $databaseConfFile = "testdb.conf";
our $dbConfFile       = "testdbconf.yml";
our $cdnConfFile      = "testcdn.conf";
our $ldapConfFile     = "testldap.conf";
our $usersConfFile    = "testusers.json";
our $profilesConfFile = "testprofiles.json";

# log file for the installer
our $logFile = "/var/log/traffic_ops/postinstall.log";

# configuration file output with answers which can be used as input to postinstall
our $outputConfigFile = "/var/log/traffic_ops/configuration_file.json";

sub errorOut {
    logger( @_, "error" );
    die;
}

# outputs logging messages to terminal and log file
# TODO: move to InstallUtils
sub logger {
    my $output = shift;
    my $type   = shift;

    my $message = $output . "\n";

    # if in debug mode or message is more critical than info print to console
    if ( $::debug || ( defined $type && $type ne "" && $type ne "info" ) ) {
        print($message);
    }

    # output to log file
    open my $fh, '>>', $::logFile or errorOut("Couldn't open log file");
    print $fh localtime . ": " . uc($type) . ' ' . $message;
    close $fh;
}

sub getDbDriver {
    return "mymysql";
}

sub getInstallPath {
    my $relPath = shift;
    return join( '/', "/tmp/traffic_ops", $relPath );
}

# given a var to the hash of config_var and question, will return the question
sub getConfigQuestion {
    my $var = shift;
    return ( keys $var )[0] eq "config_var" ? ( keys $var )[1] : ( keys $var )[0];
}

# question: The question given in the config file
# config_answer: The answer given in the config file - if no config file given will be defaultInput
# fileName: The name of the output config file given by the input config file
#
# Determines an answer to the questions asked. If an input question and answer pair is given, will return the
#  answer. If a question is given but no answer, it will prompt the user if interactive  mode is enabled, but if
#  interactive mode is not enabled it will return the default answer to the question. If there is no default answer
#  to the question and interactive mode is not enabled it will return an error and quit.

sub getField {
    my $question      = shift;
    my $config_answer = shift;
    my $fileName      = shift;

    # if there is no config file and not in automatic mode prompt for all questions with default answers
    if ( !$::inputFile && !$::automatic ) {
        return promptUser( $question, $config_answer );
    }

    return $config_answer;
}

# userInput: The entire input config file which is either user input or the defaults
# fileName: The name of the output config file given by the input config file
#
# Loops through an input config file and determines answers to each question using getField
#  and returns the hash of answers

sub getConfig {
    my $userInput = shift;
    my $fileName  = shift;

    my %config;

    if ( !defined $userInput->{$fileName} ) {
        logger( "No $fileName found in config", "error" );
    }

    logger( "===========$fileName===========", "info" );

    my $counter = 0;
    foreach my $var ( @{ $userInput->{$fileName} } ) {

        my $question = getConfigQuestion($var);

        my $answer = $config{ $var->{"config_var"} } = getField( $question, $var->{$question}, $fileName );

        $config{ $var->{"config_var"} } = $answer;
        logger( "$question:  $answer", "info" );

        $counter++;
    }
    return %config;
}

# userInput: The entire input config file which is either user input or the defaults
# dbFileName: The filename of the output config file for the database
# toDBFileName: The filename of the output config file for the Traffic Ops database
# dbAccessFileName: The filename of DBAccess
#
# Generates a config file for the database based on the questions and answers in the input config file

sub generateDbConf {
    my $userInput    = shift;
    my $dbFileName   = shift;
    my $toDBFileName = shift;

    my %dbconf = getConfig( $userInput, $dbFileName );

    make_path( dirname($dbFileName), { mode => 0755 } );
    writeJson( $dbFileName, \%dbconf );
    logger( "Database configuration has been saved", "info" );

    # broken out into separate file/config area
    my %todbconf = getConfig( $userInput, $toDBFileName );

    # No YAML library installed, but this is a simple file..
    open( my $fh, '>', $toDBFileName ) or errorOut("Can't write to $toDBFileName!");
    print $fh "version: 1.0\n";
    print $fh "name: dbconf.yml\n\n";
    print $fh "production:\n";
    print $fh "        driver: ", getDbDriver() . "\n";
    print $fh "        open: tcp:$dbconf{hostname}:$dbconf{port}*$dbconf{dbname}/$dbconf{user}/$dbconf{password}\n";
    close $fh;

    return \%todbconf;
}

# userInput: The entire input config file which is either user input or the defaults
# fileName: The filename of the output config file
#
# Generates a config file for the CDN

sub generateCdnConf {
    my $userInput = shift;
    my $fileName  = shift;

    my %cdnConfiguration = getConfig( $userInput, $fileName );

    # First,  read existing one -- already loaded with a bunch of stuff
    my $cdnConf;
    if ( -e $fileName ) {
        $cdnConf = Safe->new->rdo($fileName) or errorOut("Error loading $fileName: $@");
    }
    if ( lc $cdnConfiguration{genSecret} =~ /^y(?:es)?/ ) {
        my @secrets   = @{ $cdnConf->{secrets} };
        my $newSecret = randomWord();
        unshift @secrets, randomWord();
        if ( $cdnConfiguration{keepSecrets} > 0 && $#secrets > $cdnConfiguration{keepSecrets} - 1 ) {

            # Shorten the array to requested length
            $#secrets = $cdnConfiguration{keepSecrets} - 1;
        }
    }
    writePerl( $fileName, $cdnConf );
}

# userInput: The entire input config file which is either user input or the defaults
# fileName: The filename of the output config file
#
# Generates an LDAP config file

sub generateLdapConf {
    my $userInput = shift;
    my $fileName  = shift;

    my $useLdap = $userInput->{$fileName}[0]->{"Do you want to set up LDAP?"};

    if ( $useLdap eq "no" || $useLdap eq "n" ) {
        logger( "Not setting up ldap", "info" );

        return;
    }

    my %ldapConf = getConfig( $userInput, $fileName );

    make_path( dirname($fileName), { mode => 0755 } );
    writeJson( $fileName, \%ldapConf );
}

sub generateUsersConf {
    my $userInput = shift;
    my $fileName  = shift;

    my %user = ();
    my %config = getConfig( $userInput, $fileName );

    $user{username} = $config{tmAdminUser};
    $user{password} = sha1_hex( $config{tmAdminPw} );

    writeJson( $fileName, \%user );
}

sub generateProfilesDir {
    my $userInput = shift;
    my $fileName  = shift;

    my $userIn = $userInput->{$fileName};
}

# check default values for missing config_var parameter
sub sanityCheckDefaults {
    foreach my $file ( ( keys $::defaultInputs ) ) {
        foreach my $defaultValue ( @{ $::defaultInputs->{$file} } ) {
            my $question = getConfigQuestion($defaultValue);

            if ( !defined $defaultValue->{"config_var"} || $defaultValue->{"config_var"} eq "" ) {
                errorOut("Question \'$question\' in file \'$file\' has no config_var");
            }
        }
    }
}

# userInput: The entire input config file which is either user input or the defaults
#
# Checks the input config file against the default inputs. If there is a question located in the default inputs which
#  is not located in the input config file it will output a warning message. If in auto mode the default answer will be
#  used. If in interactive mode the user will be prompted with the default question missing from the config file
#
# This does not check the other way meaning questions which are present in defaults but not present in the input config
#  file will not be checked

sub sanityCheckConfig {
    my $userInput = shift;
    my $diffs     = 0;

    foreach my $file ( ( keys $::defaultInputs ) ) {
        if ( !defined $userInput->{$file} ) {
            logger( "File \'$file\' found in defaults but not config file", "warn" );
            $userInput->{$file} = [];
	}
        foreach my $defaultValue ( @{ $::defaultInputs->{$file} } ) {

            my $found = 0;
            foreach my $configValue ( @{ $userInput->{$file} } ) {
                if ( $defaultValue->{"config_var"} eq $configValue->{"config_var"} ) {
                    $found = 1;
                }
            }

            # if the question is not found in the config file add it from defaults
            if ( !$found ) {
                logger( "Value " . Dumper($defaultValue) . "found in defaults but not in \'$file\'", "warn" );

                my $question = getConfigQuestion($defaultValue);

                my %temp;

                # in automatic mode add the missing question with default answer
                if ($::automatic) {
                    logger( "Adding question \'$question\' with default answer \'$defaultValue->{$question}\'", "info" );

                    %temp = (
                        "config_var" => $defaultValue->{"config_var"},
                        $question    => $defaultValue->{$question}
                    );
                }

                # in interactive mode prompt the user for answer to missing question
                else {
                    logger( "Prompting user for answer", "info" );

                    my $answer = promptUser( $question, $defaultValue->{$question} );

                    %temp = ( "config_var" => $defaultValue->{"config_var"}, $question => $answer );
                }
                push $userInput->{$file}, \%temp;

                $diffs++;
            }
        }
    }

    logger( "File sanity check complete - found $diffs differences", "info" ) if ( $::debug && $diffs == 0 );
    logger( "File sanity check complete - found $diffs difference(s)", "info" ) if ( $diffs > 0 );
}

# A function which returns the default inputs data structure. These questions and answers will be used if there is no
#  user input config file or if there are questions in the input config file which do not have answers

sub getDefaults {
    return {
        $::databaseConfFile => [
            {
                "Database type" => "mysql",
                "config_var"    => "type",
            },
            {
                "Database name" => "traffic_ops",
                "config_var"    => "dbname",
            },
            {
                "Database server hostname IP or FQDN" => "localhost",
                "config_var"                          => "hostname",
            },
            {
                "Database port number" => "3306",
                "config_var"           => "port"
            },
            {
                "Traffic Ops database user" => "traffic_ops",
                "config_var"                => "user"
            },
            {
                "Password for Traffic Ops database user" => "default",
                "config_var"                             => "password"
            }
        ],
        $::dbConfFile => [
            {
                "Database server root (admin) user" => "root",
                "config_var"                        => "dbAdminUser"
            },
            {
                "Password for database server admin" => "default",
                "config_var"                         => "dbAdminPw"
            }
        ],
        $::cdnConfFile => [
            {
                "Generate a new secret?" => "yes",
                "config_var"             => "genSecret"
            },
            {
                "Number of secrets to keep?" => "10",
                "config_var"                 => "keepSecrets"
            }
        ],
        $::ldapConfFile => [
            {
                "Do you want to set up LDAP?" => "no",
                "config_var"                  => "setupLdap"
            },
            {
                "LDAP server hostname" => "",
                "config_var"           => "hostname"
            },
            {
                "LDAP Admin DN" => "",
                "config_var"    => "admin_dn"
            },
            {
                "LDAP Admin Password" => "",
                "config_var"          => "password"
            },
            {
                "LDAP Search Base" => "",
                "config_var"       => "search_base"
            }
        ],
        $::usersConfFile => [
            {
                "Administration username for Traffic Ops" => "admin",
                "config_var"                              => "tmAdminUser"
            },
            {
                "Password for the admin user" => "default",
                "config_var"                  => "tmAdminPw"
            }
        ],
        $::profilesConfFile => []
    };
}

# -d     - Debug Mode:       More output to the terminal
# -a     - Automatic mode:   If there are questions in the config file which do not have answers, the script
#                            will look to the defaults for the answer. If the answer is not in the defaults
#                            the script will exit
# -h     - Help:             Basic command line help menu
# -cfile - Input File:       The input config file used to ask and answer questions

sub main {
    our $inputFile = "";
    our $automatic = 0;
    our $debug     = 0;
    my $help = 0;

    my $usageString = "Usage: postinstall [-a] [-d] -cfile=[config_file]\n";

    GetOptions(
        "cfile=s"   => \$inputFile,
        "automatic" => \$automatic,
        "debug"     => \$debug,
        "help"      => \$help
    ) or die($usageString);

    # stores the default questions and answers
    our $defaultInputs = getDefaults();

    if ($help) {
        print $usageString;
        exit(0);
    }

    if ($::debug) {
        print "Debug is on\n";
    }

    if ( $::debug && $::automatic ) {
        print "Running in automatic mode\n";
    }

    logger( "Starting postinstall", "info" );

    # used to store the questions and answers provided by the user
    my $userInput;

    if ( $::inputFile eq "" ) {
        print "No input file given - using defaults\n" if ($::debug);
        $userInput = $::defaultInputs;
    }
    else {
        print "Using input file $::inputFile\n" if ($::debug);

        # check if the input file exists
        errorOut("File \'$::inputFile\' not found") if ( !-e $::inputFile );

        # read and store the input file
        $userInput = readJson($::inputFile);
    }

    # sanity check the defaults if running them automatically
    sanityCheckDefaults();

    # check the input config file against the defaults to check for missing questions
    sanityCheckConfig($userInput) if ( $inputFile ne "" );

    writeJson( $outputConfigFile, $userInput );

    # The generator functions handle checking input/default/automatic mode

    # todbconf will be used later when setting up the database
    generateDbConf( $userInput, $::databaseConfFile, $::dbConfFile );
    generateCdnConf( $userInput, $::cdnConfFile );
    generateLdapConf( $userInput, $::ldapConfFile );
    generateUsersConf( $userInput, $::usersConfFile );
    generateProfilesDir( $userInput, $::profilesConfFile );
}

main;

logger( "Postinstall complete\n", "info" );

# vi:syntax=perl
