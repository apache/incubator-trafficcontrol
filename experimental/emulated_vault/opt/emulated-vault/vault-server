#! /usr/bin/python

#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
#

import json
import logging
import sys
import os
import inspect
from BaseHTTPServer import HTTPServer
from BaseHTTPServer import BaseHTTPRequestHandler
import ssl
import urlparse, json
import re, fnmatch

import adaptor.fs

class RequestHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        try:
            self._do_GET()
        except:
            logger.exception("do_GET exception")

    do_HEAD = do_GET

    def do_POST(self):
        try:
            self._do_POST()
        except:
            logger.exception("do_POST exception")

    do_PUT = do_POST

    def do_DELETE(self):
        try:
            self._do_DELETE()
        except:
            logger.exception("do_DELETE exception")

    def _do_GET(self):
        logger.debug("GET %s", self.path)
        parsed_path = urlparse.urlparse(self.path)

        if parsed_path.path == "/ping":
            logger.info("Ping")
            success, value = adaptor.ping()
            if not success:
                self.send_response(503)
                self.send_header('Content-type', 'text/html')
                self.end_headers()
                self.wfile.write("Failure")
                return

            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(value)
            return

        if parsed_path.path == "/search/query/sslkeys":
            logger.info("Search SSL: path=%s query=%s", parsed_path.path, parsed_path.query)
            filters = {}
            keyFilters = {}
            cdnFind = re.search(".*q=cdn:([^&]*).*", parsed_path.query)
            if cdnFind:
                def cdnFilter(key,val):
                    try:
                        data = json.loads(val)
                        return data['cdn']==cdnFind.group(1)
                    except:
                        return False
                filters['cdn'] = cdnFilter

            dsFind = re.search(".*q=deliveryservice:([^&]*).*", parsed_path.query)
            if dsFind:
                def dsFilter(key,val):
                    try:
                        data = json.loads(val)
                        return data['deliveryservice']==dsFind.group(1)
                    except:
                        return False
                filters['ds'] = dsFilter

            keyFind = re.search(".*q=_yz_rk:([^&]*).*", parsed_path.query)
            if keyFind:
                def keyFilter(key):
                    return fnmatch.fnmatch(os.path.basename(key), keyFind.group(1))
                keyFilters['key-match'] = keyFilter

            success, parameters = adaptor.searchParameters("riak/ssl/", keyFilters=keyFilters, filters=filters)
            if not success:
                self.send_response(503)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write('{"Failure"}')
                return

            docs = []
            for key,val in parameters.iteritems():
                docs.append(json.loads(val))
            toReturn = {"response":{"numFound":len(docs),"start":0, "docs":docs}}

            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(toReturn))
            return

        logger.info("GET %s", self.path)
        success, value = adaptor.getParameter(parsed_path.path[1:])
        if not success:
            self.send_response(503)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write('{"Failure"}')
            return

        if value is None:
            self.send_response(404)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write('{"Not found"}')
            return

        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(value)

    def _do_POST(self):
        logger.info("POST %s", self.path)
        parsed_path = urlparse.urlparse(self.path)
        content_len = int(self.headers.getheader('content-length'))
        post_body = self.rfile.read(content_len)
        data = json.loads(post_body)
        #mimic vault beahvior
        if parsed_path.path.startswith('/riak/ssl/'):
            for item in data['certificate']:
                data['certificate.%s'%item]=data['certificate'][item]
        success = adaptor.setParameter(parsed_path.path[1:], json.dumps(data))
        if not success:
            self.send_response(503)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write('{"Failure"}')
            return

        self.send_response(204)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        return


    def _do_DELETE(self):
        logger.info("DELETE %s", self.path)
        parsed_path = urlparse.urlparse(self.path)

        success = adaptor.deleteParameter(parsed_path.path[1:])
        if not success:
            self.send_response(503)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write('{"Failure"}')
            return

        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write('{"Deleted"}')
        return



if __name__ == '__main__':
    progPath = inspect.stack()[-1][1]
    progAbsPath = os.path.abspath( progPath )
    progAbsPath = os.path.dirname(os.path.normpath(progAbsPath))

    confDir = os.path.join(progAbsPath, "conf")
    confFile = os.path.join(confDir, "cfg.json")
    with open(confFile) as fd:
        cfg = json.load(fd)

    logDir = os.path.join(progAbsPath, "var/log")
    debugLogFile = os.path.join(logDir, "traffic-ops-vault-debug.log")
    mainLogFile = os.path.join(logDir, "traffic-ops-vault.log")
    if not os.path.exists(logDir):
        os.makedirs(logDir)

    global logger
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    # create file handler which logs even debug messages
    fhd = logging.FileHandler(debugLogFile)
    fhd.setLevel(logging.DEBUG)
    fhm = logging.FileHandler(mainLogFile)
    fhm.setLevel(logging.INFO)
    # create formatter and add it to the handlers
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    fhm.setFormatter(formatter)
    fhd.setFormatter(formatter)
    # add the handlers to the logger
    logger.addHandler(fhm)
    logger.addHandler(fhd)

    basePath = cfg["data"]["db-path"]
    pingRelPath = cfg["data"]["ping-rel-path"]
    listenIP = cfg["data"]["listen-ip"]
    listenPort = cfg["data"]["listen-port"]
    adaptorType = cfg["data"]["adaptor-type"]
    use_ssl = cfg["data"]["use-ssl"]

    global adaptor
    if adaptorType == "fs":
        adaptor = adaptor.fs.Fs(logger=logger, basePath=basePath, pingRelPath=pingRelPath)
    else:
        logger.error("Invalid adaptor type '%s'", adaptorType)
        sys.exit(1)

    if not adaptor.init_ping():
        logger.error("Failed initialization")
        sys.exit(1)        

    server = HTTPServer((listenIP, listenPort), RequestHandler)
    if use_ssl:
        key = cfg["data"]["ssl-key-path"]
        cert = cfg["data"]["ssl-cert-path"]
        server.socket = ssl.wrap_socket (server.socket, keyfile=key, certfile=cert, server_side=True)
    msg = 'Starting server at http%s://%s:%d'%("s" if use_ssl else "", listenIP, listenPort)
    print >> sys.stderr, msg
    logger.info(msg)
    server.serve_forever()
